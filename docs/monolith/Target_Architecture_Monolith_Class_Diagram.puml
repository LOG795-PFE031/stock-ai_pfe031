@startuml

title Target Monolith Architecture -  Class Diagram

skinparam linetype ortho
skinparam defaultFontSize 18

class BaseService << abstract >> {
  +initialize(): None
  +cleanup(): None
}

note right of BaseService
This is the base interface for all 
services (identified by <<Service>>).
end note

package "ML Pipeline" as mp <<Frame>> { 

  class DataService <<Service>> {
    +get_stock_data(): Dict
  }

  package Preprocessing <<Frame>> {

    class PreprocessingService <<Service>> {
      +prepare_data(): Dict
    }

    interface DataProcessor {
      +process(data: Dict): Dict
    }

    PreprocessingService --o "1..*" DataProcessor

    class DataCleaner {
      +process(data: Dict): Dict
    }

    class FeatureBuilder {
      +process(data: Dict): Dict
    }

    note bottom of FeatureBuilder
    Add features (calculate_technical_indicators)
    end note

    class FeatureSelector {
      +process(data: Dict): Dict
    }

    note bottom of FeatureSelector
    Select only the features required by a specific model.
    end note

    class TargetBuilder {
      +process(data: Dict): Dict
    }

    class DataSplitter {
      +process(data: Dict): Dict
    }

    note bottom of DataSplitter
    Split data into train and test datasets
    end note

    class DataNormalizer {
      +process(data: Dict): Dict
    }

    note bottom of DataNormalizer
    Scales the data (and fits if in training mode).
    end note

    DataProcessor <|.. DataCleaner
    DataProcessor <|.. FeatureBuilder
    DataProcessor <|.. FeatureSelector
    DataProcessor <|.. DataSplitter
    DataProcessor <|.. TargetBuilder
    DataProcessor <|.. DataNormalizer
  }

  package Deployment <<Frame>> {

    class DeploymentService <<Service>> {
      +predict(model_name: String): Dict
      +list_models(): Dict
      +promote_model(model_name: String): Dict
    }

    class ModelManager {
      +load_model(model_name: String, production: bool = True)
      +promote_model(model_name: String)
      +get_model_metrics(model_name: String, production: bool = True)
      +update_model_metrics(model_name: String, metrics: Dict, production: bool = True)
    }

    DeploymentService --o ModelManager

    class Evaluator {
      +evaluate_model(y_true: Dict, y_pred: Dict): Dict
      +_calculate_metrics(y_true: Dict, y_pred: Dict): Dict
    }

    DeploymentService --o Evaluator

    class Predicator {
      +predict(model: MLFlow.PyFuncModel, data: Dict)
    }

    note bottom of Predicator
    It may be worth considering prediction directly inside the Deployment service,
    removing the need for a dedicated Predictor class.
    end note

    DeploymentService --o Predicator

  }

  package Training <<Frame>> {
    class TrainingService <<Service>> {
      +train_model(): Dict
      +list_trainers(): Dict
      +get_training_status(): Dict
    }

    class TrainerRegistry {
      +register(trainer_name: String): None
      +create(trainer_name: String): BaseTrainer
      +list_trainers(): Dict
    }

    TrainingService --> TrainerRegistry : create(trainer_name)

    class BaseTrainer {
      +train()
      +predict()
    }

    TrainerRegistry --> BaseTrainer : creates

    class LSTMTrainer {
      +train(): Tuple
      +predict(): Dict
    }

    class XGBoost {
      +train(): Tuple
      +predict(): Dict
    }

    class ProphetTrainer {
      +train(): Tuple
      +predict(): Dict
    }

    ' The models implement the interface BaseTrainer
    BaseTrainer <|.. ProphetTrainer
    BaseTrainer <|.. LSTMTrainer
    BaseTrainer <|.. XGBoost
  }
}

class MonitoringService <<Service>> {
  +collect_model_metrics(): Dict
  +collect_sre_metrics(): Dict
  +monitor_model_accuracy() :Dict
  +trigger_retraining(): Dict
}

package Orchestration <<Frame>> {
  class OrchestrationService <<Service>> {
    +initialize(): None
    +cleanup(): None
    +run_training_pipeline(): Dict
    +run_prediction_pipeline(): Dict
    +run_evaluation_pipeline(): Dict
    +get_pipeline_status(): Dict
  }

  class TrainingPipeline <<module>> {
    +run_training_pipeline(): Dict
  }

  

  OrchestrationService o-- TrainingPipeline

  class PredictionPipeline <<module>> {
    +run_prediction_pipeline(): Dict
  }

  OrchestrationService o-- PredictionPipeline

  class EvaluationPipeline <<module>> {
    +run_evaluation_pipeline(): Dict
  }

  OrchestrationService o-- EvaluationPipeline
}

note bottom of Orchestration
All the pipeline are modules if we want to use 
Prefect. Should these pipelines modules call the 
services, or should it be the OrchestrationService class ?
end note

' Monitoring service relationship
MonitoringService --> mp : monitors
Orchestration <-- MonitoringService : notifies

' Key orchestration relationship
mp <-- Orchestration : triggers

@enduml
